                       **Report**
                        Lab 3-paths
               Julia Goldman + Matheus de Carvalho Souza
               jsg2@williams.edu             
               mc13@williams.edu           

Design
======================================================
We have a [PathTracer]() class, which keeps a TriTree of all the triangles in the scene as state, as well as all the specifications passed in through the GUI. To trace an image, the user calls [traceImage](), providing a camera and an image. Trace image has two main for loops, one within the other. The outer loops in the number of paths. It will [generatePrimaryRays]() in a buffer for each one, and sets the modulation buffer to 1/(the number of rays). Then within the for loop, we loop in the number of scattering events. We fill our surfel buffer with the surfel hit by the primary ray of each pixel. Then, we [computeShadowRays]() for each pixel in parallel. In doing so, we choose a light by sampling, and then cast a ray from the light to the surfel, and store light's biradiance, weighed by the probability of choosing it, in our biradiance buffer. Then, we fill our shadowRayBuffer by attempting to intersect our shadow rays with closer surfels, determining whether or not a shadow in cast. Having determined that, we [writeToImage] in parallel. In doing that, we..


Results
======================================================
    Eye ray directions
    -------------------------------------------------
    
    ![Eye ray directions](http://graphicscodex.com/projects/paths/eye-ray-directions.jpg)

    World-space hit positions for Cornell Box
    -------------------------------------------------

    ![World-space hit positions](http://graphicscodex.com/projects/paths/positions.png)

    World-space geometric surface normals for Cornell Box
    -------------------------------------------------

    ![World-space geometric surface normals](http://graphicscodex.com/projects/paths/normals.png)

    Cornell Box (one path per pixel)
    -------------------------------------------------
    
    ![Cornell Box - 1 path per pixel](http://graphicscodex.com/projects/paths/direct.png)

    Box with spheres (128 paths per pixel)
    -------------------------------------------------
   
    ![One scattering event](http://graphicscodex.com/projects/paths/1.png width=200px) ![Two scattering events](http://graphicscodex.com/projects/paths/2.png width=200px) ![Three scattering events](http://graphicscodex.com/projects/paths/3.png width=200px) ![Four scattering events](http://graphicscodex.com/projects/paths/4.png width=200px) ![Ten scattering events](http://graphicscodex.com/projects/paths/10.png width=200px)

Performance
========================================================
    Rendering of Sponza - One path per pixel
    -------------------------------------------------

    ![Scattering depth vs. Time](AnalyticSpheres2.png)

    Rendering of Sponza - Scattering depth of 1 
    -------------------------------------------------

    ![Paths per pixel vs. Time](AnalyticSpheres2.png)


Quality Demonstration
========================================================

![Scene Name. Rendered at 1280x720.](AnalyticSpheres2.png)

Phenomena Demonstration
========================================================

![Global illumination Effect](AnalyticSpheres2.png)

![Global illumination Effect](AnalyticSpheres2.png)

![Global illumination Effect](AnalyticSpheres2.png)

![Global illumination Effect](AnalyticSpheres2.png)

Question
========================================================
 1. Why does it take four scattering events to produce a caustic? Give a diagram
      or otherwise explain what those events are.

It takes four scattering events to produce a caustic, since... something to do with hemispheres?

 2. Derive an asymptotic bound on the run time of the global illumination renderer from the
      Rays project, were it to recurse to an arbitrary path depth. Recall that it traced one
      primary ray per pixel, computed direct illumination from all sources, and then spawned
      $r$ recursive rays. Use the variables: $n$ pixels, $d$ maximum path depth, $p$ primary
      rays per pixel, $L$ lights in the scene. It may help to draw a tree of the recursive
      calls.

$O(n*d*p*L). (Will actually have powers, because recursion.)$

 3. Derive an asymptotic bound on the run time of the path tracer from this project using the
      same variables from the previous question.

$O(n*d*p*L)$

 4. Derive an algorithm to sample the numbers from 0 to 100 proportional to their value.
      For example, write a random integer generator in which zero will never be returned,
      two will be returned twice as often as one, 100 will be returned twice as frequently
      as 50, and so on. Assume that you already have a uniform random number generator on
      the interval [0, 100].

To sample the numbers from 0 to 100...

5. In your own words (and with equations and diagrams as needed), present an mathematically
      rigorous argument that path tracing as presented in this project converges to a true
      solution to the rendering equation as the path length and number of paths per pixel
      approach infinity. State any assumptions underlying that argument explicitly.

Assumptions:


Self Review
========================================================
Grade: ?
Code Design:
Code Readability:
Expected Code Correctness:
Report Quality:
Report Correctness:
Workflow:

Skills
========================================================
Software Engineering:
Algorithmic Skills:
Mathematical Skills:

Time
========================================================
Minimum Viable Product:
Polishing:



<!-- Markdeep: -->
<style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace;}</style><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>